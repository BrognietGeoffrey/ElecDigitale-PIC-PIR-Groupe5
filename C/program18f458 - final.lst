CCS PCH C Compiler, Version 5.101Pd, 1               17-mai-21 09:52
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\brogn\Documents\program18f458 - final.lst

               ROM used:   968 bytes (3%)
                           Largest free fragment is 31796
               RAM used:   42 (3%) at main() level
                           54 (4%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   02BA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00F6
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <program18f458 - final.h>
.................... #include <18F458.h>
.................... //////////// Standard Header file for the PIC18F458 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F458
*
015E:  MOVF   2F,W
0160:  CLRF   01
0162:  SUBWF  2E,W
0164:  BC    016C
0166:  MOVFF  2E,00
016A:  BRA    0184
016C:  CLRF   00
016E:  MOVLW  08
0170:  MOVWF  30
0172:  RLCF   2E,F
0174:  RLCF   00,F
0176:  MOVF   2F,W
0178:  SUBWF  00,W
017A:  BTFSC  FD8.0
017C:  MOVWF  00
017E:  RLCF   01,F
0180:  DECFSZ 30,F
0182:  BRA    0172
0184:  RETURN 0
*
020E:  MOVLW  20
0210:  BTFSS  29.4
0212:  MOVLW  30
0214:  MOVWF  2A
0216:  MOVFF  28,00
021A:  BTFSS  28.7
021C:  BRA    022E
021E:  COMF   00,F
0220:  INCF   00,F
0222:  MOVFF  00,28
0226:  MOVLW  2D
0228:  MOVWF  2A
022A:  BSF    29.7
022C:  BSF    29.0
022E:  MOVF   01,W
0230:  MOVFF  28,2E
0234:  MOVLW  64
0236:  MOVWF  2F
0238:  RCALL  015E
023A:  MOVFF  00,28
023E:  MOVLW  30
0240:  ADDWF  01,W
0242:  MOVWF  2B
0244:  MOVFF  28,2E
0248:  MOVLW  0A
024A:  MOVWF  2F
024C:  RCALL  015E
024E:  MOVLW  30
0250:  ADDWF  00,W
0252:  MOVWF  2D
0254:  MOVLW  30
0256:  ADDWF  01,W
0258:  MOVWF  2C
025A:  MOVFF  2A,00
025E:  MOVLW  30
0260:  SUBWF  2B,W
0262:  BZ    026C
0264:  BSF    29.1
0266:  BTFSC  29.7
0268:  BSF    29.2
026A:  BRA    0290
026C:  MOVFF  2A,2B
0270:  MOVLW  20
0272:  MOVWF  2A
0274:  MOVLW  30
0276:  SUBWF  2C,W
0278:  BZ    0282
027A:  BSF    29.0
027C:  BTFSC  29.7
027E:  BSF    29.1
0280:  BRA    0290
0282:  BTFSS  FD8.2
0284:  BSF    29.0
0286:  BNZ   0290
0288:  MOVFF  2B,2C
028C:  MOVLW  20
028E:  MOVWF  2B
0290:  BTFSC  29.2
0292:  BRA    029E
0294:  BTFSC  29.1
0296:  BRA    02A4
0298:  BTFSC  29.0
029A:  BRA    02AA
029C:  BRA    02B0
029E:  MOVFF  2A,2E
02A2:  RCALL  01CE
02A4:  MOVFF  2B,2E
02A8:  RCALL  01CE
02AA:  MOVFF  2C,2E
02AE:  RCALL  01CE
02B0:  MOVFF  2D,2E
02B4:  RCALL  01CE
02B6:  GOTO   03C0 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #use delay(crystal=20000000)
*
0138:  CLRF   FEA
013A:  MOVLW  29
013C:  MOVWF  FE9
013E:  MOVF   FEF,W
0140:  BZ    015C
0142:  MOVLW  06
0144:  MOVWF  01
0146:  CLRF   00
0148:  DECFSZ 00,F
014A:  BRA    0148
014C:  DECFSZ 01,F
014E:  BRA    0146
0150:  MOVLW  7B
0152:  MOVWF  00
0154:  DECFSZ 00,F
0156:  BRA    0154
0158:  DECFSZ FEF,F
015A:  BRA    0142
015C:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1,FORCE_SW)
*
00AE:  BSF    F94.7
00B0:  BTFSC  F82.7
00B2:  BRA    00B0
00B4:  MOVLW  08
00B6:  MOVWF  00
00B8:  CLRF   35
00BA:  BSF    00.7
00BC:  BRA    00DA
00BE:  BCF    00.7
00C0:  BRA    00DA
00C2:  BCF    FD8.0
00C4:  BTFSC  F82.7
00C6:  BSF    FD8.0
00C8:  RRCF   35,F
00CA:  BSF    00.6
00CC:  BRA    00DA
00CE:  BCF    00.6
00D0:  DECFSZ 00,F
00D2:  BRA    00C2
00D4:  MOVFF  35,01
00D8:  BRA    00F2
00DA:  MOVLW  A7
00DC:  BTFSC  00.7
00DE:  MOVLW  2D
00E0:  MOVWF  01
00E2:  DECFSZ 01,F
00E4:  BRA    00E2
00E6:  NOP   
00E8:  BTFSC  00.7
00EA:  BRA    00BE
00EC:  BTFSC  00.6
00EE:  BRA    00CE
00F0:  BRA    00C2
00F2:  GOTO   010E (RETURN)
*
01CE:  BCF    F94.6
01D0:  BCF    F8B.6
01D2:  MOVLW  08
01D4:  MOVWF  01
01D6:  BRA    01D8
01D8:  NOP   
01DA:  BSF    01.7
01DC:  BRA    01FA
01DE:  BCF    01.7
01E0:  RRCF   2E,F
01E2:  BTFSC  FD8.0
01E4:  BSF    F8B.6
01E6:  BTFSS  FD8.0
01E8:  BCF    F8B.6
01EA:  BSF    01.6
01EC:  BRA    01FA
01EE:  BCF    01.6
01F0:  DECFSZ 01,F
01F2:  BRA    01E0
01F4:  BRA    01F6
01F6:  NOP   
01F8:  BSF    F8B.6
01FA:  MOVLW  A7
01FC:  MOVWF  FE9
01FE:  DECFSZ FE9,F
0200:  BRA    01FE
0202:  BRA    0204
0204:  BTFSC  01.7
0206:  BRA    01DE
0208:  BTFSC  01.6
020A:  BRA    01EE
020C:  RETURN 0
.................... 
.................... int convertisseurSortie(int valeur);
.................... 
.................... // Pin aliases
.................... #define LED_ROUGE   PIN_E1
.................... #define LED_VERT PIN_E2
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #define BUFFER_SIZE 3
.................... 
.................... 
.................... char buffer[BUFFER_SIZE];
.................... 
.................... int toRead=0; // Flag pour actualisation du seuil
.................... int compteur=0; // Nombre de caractère écrit
.................... int i, x;
.................... boolean f_plein = false;
.................... boolean change = false;
.................... int nb_personne = 0;
.................... 
.................... // Interruption quand on reçoit des données 
.................... #INT_RDA
.................... void RDA_isr(void)
.................... {
....................    buffer[compteur] = getc();
*
00F6:  CLRF   03
00F8:  MOVF   1F,W
00FA:  ADDLW  1B
00FC:  MOVWF  FE9
00FE:  MOVLW  00
0100:  ADDWFC 03,W
0102:  MOVWF  FEA
0104:  MOVFF  FEA,34
0108:  MOVFF  FE9,33
010C:  BRA    00AE
010E:  MOVFF  34,FEA
0112:  MOVFF  33,FE9
0116:  MOVFF  01,FEF
....................    if(buffer[0]=='!' && toRead==0){
011A:  MOVF   1B,W
011C:  SUBLW  21
011E:  BNZ   0132
0120:  MOVF   1E,F
0122:  BNZ   0132
....................       compteur++;
0124:  INCF   1F,F
....................       if(compteur>=4){
0126:  MOVF   1F,W
0128:  SUBLW  03
012A:  BC    0132
....................          compteur=0;
012C:  CLRF   1F
....................          toRead=1;
012E:  MOVLW  01
0130:  MOVWF  1E
....................       }
....................    } 
0132:  BCF    F9E.5
0134:  GOTO   0060
.................... }
.................... 
.................... // Convertir le nombre de personnes en un nombre à envoyer sur les pins des afficheurs 7 segments
.................... int convertisseurSortie(int valeur){
*
0186:  CLRF   29
....................    int sortie = 0;
....................    if (valeur < 10) {
0188:  MOVF   28,W
018A:  SUBLW  09
018C:  BNC   0198
....................       sortie = valeur*16;
018E:  MOVF   28,W
0190:  MULLW  10
0192:  MOVFF  FF3,29
....................    } else {
0196:  BRA    01C6
....................        x = valeur;
0198:  MOVFF  28,21
....................        x = x % 10;
019C:  MOVFF  21,2E
01A0:  MOVLW  0A
01A2:  MOVWF  2F
01A4:  RCALL  015E
01A6:  MOVFF  00,21
....................        i = valeur;
01AA:  MOVFF  28,20
....................        i = i/10;
01AE:  MOVFF  20,2E
01B2:  MOVLW  0A
01B4:  MOVWF  2F
01B6:  RCALL  015E
01B8:  MOVFF  01,20
.................... 
....................        sortie = i + x*16;
01BC:  MOVF   21,W
01BE:  MULLW  10
01C0:  MOVF   FF3,W
01C2:  ADDWF  20,W
01C4:  MOVWF  29
....................    }
....................    return sortie;
01C6:  MOVFF  29,01
01CA:  GOTO   038C (RETURN)
.................... }
.................... 
.................... void main()
*
02BA:  CLRF   FF8
02BC:  BCF    FD0.7
02BE:  BSF    07.7
02C0:  BCF    F94.6
02C2:  BSF    F8B.6
02C4:  CLRF   1E
02C6:  CLRF   1F
02C8:  BCF    22.0
02CA:  BCF    22.1
02CC:  CLRF   23
02CE:  BSF    FC1.0
02D0:  BSF    FC1.1
02D2:  BSF    FC1.2
02D4:  BCF    FC1.3
02D6:  MOVLW  07
02D8:  MOVWF  FB4
02DA:  CLRF   19
02DC:  CLRF   1A
02DE:  CLRF   24
02E0:  MOVLW  03
02E2:  MOVWF  25
.................... {
....................    int nb_personne = 0;
....................    int nb_max_personne = 3;
.................... 
....................    // Initialiser les interruptions
....................    enable_interrupts(INT_RDA);
02E4:  BSF    F9D.5
....................    enable_interrupts(GLOBAL);
02E6:  MOVLW  C0
02E8:  IORWF  FF2,F
.................... 
....................    // setup de base
....................    setup_low_volt_detect(false);
02EA:  CLRF   FD2
....................    setup_timer_0(RTCC_INTERNAL);
02EC:  MOVLW  80
02EE:  MOVWF  FD5
....................    setup_adc_ports(NO_ANALOGS);
02F0:  BSF    FC1.0
02F2:  BSF    FC1.1
02F4:  BSF    FC1.2
02F6:  BCF    FC1.3
....................    setup_adc(ADC_OFF);
02F8:  BCF    FC2.0
....................    setup_spi(FALSE);
02FA:  CLRF   FC6
....................    setup_wdt(WDT_OFF);
02FC:  BCF    FD1.0
....................    setup_timer_1( T1_INTERNAL | T1_DIV_BY_1  );
02FE:  MOVLW  85
0300:  MOVWF  FCD
....................    setup_comparator(NC_NC_NC_NC);
0302:  MOVLW  07
0304:  MOVWF  FB4
0306:  MOVF   F95,W
0308:  MOVWF  F95
030A:  MOVF   F96,W
030C:  MOVWF  F96
030E:  MOVLW  10
0310:  MOVWF  00
0312:  DECFSZ 00,F
0314:  BRA    0312
0316:  NOP   
0318:  MOVF   FB4,W
031A:  BCF    FA1.6
....................    setup_vref(FALSE);
031C:  CLRF   FB5
....................    setup_oscillator(False);
031E:  CLRF   FD3
....................    
....................    // Allumer les leds
....................    output_high(LED_VERT);
0320:  BCF    F96.2
0322:  BSF    F8D.2
....................    output_low(LED_ROUGE);
0324:  BCF    F96.1
0326:  BCF    F8D.1
.................... 
....................    // Boucle du programme
....................    while(true)
....................    {
....................       set_adc_channel(0);// pin non utiliser pas neccessaire 
0328:  MOVLW  00
032A:  MOVWF  01
032C:  MOVF   FC2,W
032E:  ANDLW  C7
0330:  IORWF  01,W
0332:  MOVWF  FC2
.................... 
....................       // Vérification de l'état des entrées / sorties
....................       if (input(PIN_C0) == 0 && input(PIN_C1) == 1) {
0334:  BSF    F94.0
0336:  BTFSC  F82.0
0338:  BRA    0356
033A:  BSF    F94.1
033C:  BTFSS  F82.1
033E:  BRA    0356
....................          change = true;
0340:  BSF    22.1
....................          nb_personne += 1;
0342:  MOVLW  01
0344:  ADDWF  24,F
....................          delay_ms(1000);
0346:  MOVLW  04
0348:  MOVWF  28
034A:  MOVLW  FA
034C:  MOVWF  29
034E:  RCALL  0138
0350:  DECFSZ 28,F
0352:  BRA    034A
....................       } else if (input(PIN_C0) == 1 && input(PIN_C1) == 0) {
0354:  BRA    037A
0356:  BSF    F94.0
0358:  BTFSS  F82.0
035A:  BRA    037A
035C:  BSF    F94.1
035E:  BTFSC  F82.1
0360:  BRA    037A
....................          if (nb_personne > 0) {
0362:  MOVF   24,F
0364:  BZ    037A
....................             change = true;
0366:  BSF    22.1
....................             nb_personne -= 1;
0368:  MOVLW  01
036A:  SUBWF  24,F
....................             delay_ms(1000);
036C:  MOVLW  04
036E:  MOVWF  28
0370:  MOVLW  FA
0372:  MOVWF  29
0374:  RCALL  0138
0376:  DECFSZ 28,F
0378:  BRA    0370
....................          }
....................       }
.................... 
....................       if(toRead) {
037A:  MOVF   1E,F
037C:  BZ    0382
....................          nb_max_personne = buffer[1];
037E:  MOVFF  1C,25
....................       }
.................... 
....................       // Si le nombre de personne dans la salle change
....................       if (change) {
0382:  BTFSS  22.1
0384:  BRA    03C2
....................          int sortie = convertisseurSortie(nb_personne);
0386:  MOVFF  24,28
038A:  BRA    0186
038C:  MOVFF  01,26
....................          output_b(sortie); // Afficher le nombre de personnes sur les afficheurs
0390:  CLRF   F93
0392:  MOVFF  26,F8A
.................... 
....................          // Gérer les leds en fonction du nombre de personne
....................          boolean f_plein = nb_personne >= nb_max_personne;
0396:  BCF    27.0
0398:  MOVF   25,W
039A:  SUBWF  24,W
039C:  BNC   03A0
039E:  BSF    27.0
....................          if (f_plein) {
03A0:  BTFSS  27.0
03A2:  BRA    03AE
....................             output_toggle(LED_ROUGE);
03A4:  BCF    F96.1
03A6:  BTG    F8D.1
....................             output_low(LED_VERT);
03A8:  BCF    F96.2
03AA:  BCF    F8D.2
....................          } else {
03AC:  BRA    03B6
....................             output_low(LED_ROUGE);
03AE:  BCF    F96.1
03B0:  BCF    F8D.1
....................             output_high(LED_VERT);
03B2:  BCF    F96.2
03B4:  BSF    F8D.2
....................          }
....................          // Imprimer le nombre de personne sur le port COM
....................          printf("%d", nb_personne);
03B6:  MOVFF  24,28
03BA:  MOVLW  18
03BC:  MOVWF  29
03BE:  BRA    020E
....................          change = false;
03C0:  BCF    22.1
....................       }
....................       delay_ms(200);
03C2:  MOVLW  C8
03C4:  MOVWF  29
03C6:  RCALL  0138
03C8:  BRA    0328
....................    }
.................... }
03CA:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV25 NOWDT WDT128
   Word  3: 0000  
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
